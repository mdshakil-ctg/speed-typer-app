<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blogs</title>
    <link rel="stylesheet" href="styles.css" />
</head>
<body>
    
    <div class="main-header">
        <h2 class="title"><img src="./logo.png" /></h2>
        <h1>This Is The Latest Blogs</h1>
        <a href="./index.html"><button>Home</button></a>
    </div>

    <div class="blogs">
        <h2>What is the difference between local storage and session storage?</h2>
        <p>sessionStorage is similar to localStorage ; the difference is that while data in localStorage doesn't expire, data in sessionStorage is cleared when the page session ends. Whenever a document is loaded in a particular tab in the browser, a unique page session gets created and assigned to that particular tab.</p>
    </div>
    <div class="blogs">
        <h2>What is the difference between global scope & block scope?</h2>
        <p>The variables defined outside of any function or curly brackets are known as global variables and have global scope. Global scope means that the variables can be accessed from any part of that program, any function or conditional state can access that variable.</p><br>
        <p>If you were to define some variables inside curly brackets {} or inside a specific function then those variables are called local variables The local variables have a very confined scope which is called the local scope But, with the release of ES6, the local scope was further broken down into two different scopes</p>
    </div>
    <div class="blogs">
        <h2>How does javascript event loop works?</h2>
        <p>We’ll start with a somewhat of an odd claim — despite allowing async JavaScript code (like the setTimeout we just discussed), until ES6, JavaScript itself has actually never had any direct notion of asynchronicity built into it. The JavaScript engine has never done anything more than executing a single chunk of your program at any given moment.

            For more details on how JavaScript engines work (Google’s V8 specifically), check one of our previous articles on the topic.
            
            So, who tells the JS Engine to execute chunks of your program? In reality, the JS Engine doesn’t run in isolation — it runs inside a hosting environment, which for most developers is the typical web browser or Node.js. Actually, nowadays, JavaScript gets embedded into all kinds of devices, from robots to light bulbs. Every single device represents a different type of hosting environment for the JS Engine.
            
            The common denominator in all environments is a built-in mechanism called the event loop, which handles the execution of multiple chunks of your program over time, each time invoking the JS Engine.
            
            This means that the JS Engine is just an on-demand execution environment for any arbitrary JS code. It’s the surrounding environment that schedules the events (the JS code executions).
            
            So, for example, when your JavaScript program makes an Ajax request to fetch some data from the server, you set up the “response” code in a function (the “callback”), and the JS Engine tells the hosting environment:
            “Hey, I’m going to suspend execution for now, but whenever you finish with that network request, and you have some data, please call this function back.”
            
            The browser is then set up to listen for the response from the network, and when it has something to return to you, it will schedule the callback function to be executed by inserting it into the event loop.</p>
    </div>
    <div class="blogs">
        <h2>Scenarios that create undefined</h2>
        <ul>
            <li>Uninitialized variable.</li>
            <li>Accessing a non-existing property.</li>
            <li>Function null parameters.</li>
            <li>Function no return value.</li>
            <li>void operator.</li>
            <li>undefined in arrays null index.</li>
        </ul>
    </div>
</body>
</html>